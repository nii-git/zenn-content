---
title: "The Go Blog - ガイド付き最適化のプレビュー"
emoji: "😃"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["go","翻訳"]
published: false
---

# Outline
本記事はThe Go Blogの"Profile-guided optimization preview"を翻訳したものになります。
誤訳等や読みづらい点がありましたらコメント/Githubのissueにご連絡いただけると幸いです。

https://go.dev/blog/pgo-preview

# Profile-guided optimization preview
2023年2月8日 Michael Pratt

---

Goバイナリをビルドする際、コンパイラはできるだけパフォーマンスが高いバイナリを生成しようと最適化を行います。
下記は最適化の一例です: 
- 定数伝播: 定数式をコンパイル時に評価し、実行時の評価時間を削減
- エスケープ解析: ローカルに割り振られたオブジェクトへのheap割り当てを回避し、ガーベジコレクションのオーバーヘッドを削減
- インライン展開: 単純な関数を呼び出し側にコピーすることで、呼び出し側の最適化(さらなる定数伝播やエスケープ解析など)を可能に

Go言語はリリースを重ねるごとに最適化を改善していますが、これは簡単なことではありません。
いくつかの最適化手法は調整可能ですが、コンパイラがすべての関数の性能を11倍にすることはできません。
過度な最適化はパフォーマンスを損なったり、ビルド時間が著しく長くなってしまうかもしれないからです。
他の最適化手法ではコンパイラに一般的なパスとそうでないパスの判断を委ねるというものもあります。
しかしこの手法では、実行時までどちらのケースが一般的なパスなのかを知ることができないため、コンパイラは最善の推測をしなくてはなりません。

もしそれができるとしたら...？

どのコードが本番環境で使われているかの決定的な情報がないので、コンパイラはパッケージのソースコードだけしか操作することができません。
しかし我々には本番環境の振る舞いを評価するツールがあります。プロファイリングです。
コンパイルにプロファイルを渡すことができたら、より賢い選択をすることができるでしょう。
例えば、より使用される関数を積極的に最適化できたり、より正確に一般的なケースを選択したり、などです。

このように、アプリケーションの振る舞いのプロファイルをコンパイラで使用する手法を`Profile-Guided Optimization`と呼びます(Feedback-Directed Optimizationとも呼ばれます)。

Go 1.20では、初めてPGOをプレビュー版としてサポートするバージョンです。
完全なガイドを閲覧するためには[profile-guided optimization user guide](https://go.dev/doc/pgo)を参照してください。
これらはまだ荒削りな部分が残っているので商用環境では使用しない方が良いでしょう。
しかしあなたが試してみて、私たちに様々なフィードバックや[見つけたバグ](https://github.com/golang/go/issues/new/choose)を送ってくれることを心よりお待ちしております。


# 関連記事
宣伝となってしまい申し訳ないのですが、Go 1.20リリース記事を翻訳した記事もありますのでこちらもどうぞ。

https://zenn.dev/nii/articles/read-go-1-20-release-article
https://zenn.dev/nii/articles/read-go-1-20-release-article2